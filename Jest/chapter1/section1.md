# 섹션1

- render → jsx에 관한 가상 Dom을 생성한다.
- 단언 :  테스트 성공과 실패의 원인

expect : 전역메서드로 인수는 단언하는 것으로 예측이 들어맞는지 테스트하는것,

 toBeInThDocument : jestDom에서 온 Matcher 라고한다. 

- 단언은 언제나 expect로 시작한다.
- .expect(element.textContent).toBe(’hello’)
- 매쳐는 간단하게 요약할 수 있다.
- .expect(elementsArray).toHaveLength(7)

### jestDom

- cra 할 때 알아서 깔린다
- src/setupTest.js 를 이용해 모든 테스트에서 jest매쳐를 사용할 수 있다.
- Dom Based Mather- toBe toHaveLength
- toBeInThDocument - jestMather - 가상 Dom에만 접근가능

Jest 

RTL

- ReactTestingLibrary,
- 컴포넌트를 가상 Dom으로 렌더링하는데 도움이 됨
- 가상돔을 찾는데 도움이 됨
- 가상 돔과 상호작용 가능

TestRunner가 필요함

- 테스트를 찾고, 실행하고 단언하는것
- 추천되는 라이브러리다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ab03c77-c7e3-428b-a110-08aada50313f/Untitled.png)

- test할때 그 이면에 제스트가 실행중이다.
- watch 모드는 제스트를 실행하는 방법으로 라스트 커밋이후로 변경된 파일을 찾는다.
- 그리고 온리 런한다. 그 파일들과 연관된 test만
- 만약 마지막 커밋이후 변경된 파일이 없다면, 테스트를 하지 않는다.

Jest 는 어떻게 동작할까?

- global test 메소드는 두가지 인수를 가지고있다.
- 첫번째는 문자열 설명이며- 테스트에 실패했는지 설명이 쓰여있다.
- 두번째는 테스트 함수, 테스트의 성공과 실패를 결정하기 위해 이 함수를 실행
- 단언(assertion)은 예상이 틀렸을 때 에러를 던진다.
- 에러가 없다면 테스트를 통과 ⇒ 에러가 있다면  fail 이다.
- 때문에 빈 테스트도 통과한다. 에러가 없으니까.

## 테스트 주도 개발 TDD

- 코드 작성전에 테스트를 작성하고, 테스트에 통과하도록 코드를 작성하는 원리
- “red-green” testing이라고 한다.
- 코드 작성 전엔 테스트를 실패하는 코드를 작성하고 코드 작성후엔 테스트가 통과하도록 한다.
- 아무것도 작성하지 않았기에 (실패하게 만드는 코드) 코드가 실패하면 그때 코드를 작성에서 테스트를 통과시킴

### 왜 TDD를 사용하나 ?

- 테스트는 마지막으로 해야하는 따분한 일이 아니라 코딩 프로세스라는 느낌을 느낀다.
- 좀 더 효율적이다. 애플리케이션을 실행해서 하는건 수동테스트다. 하지만 코드작성 전에 테스트코드를 하면 변경후에 자동으로 테스트를 해준다. 변경사항이 생길 때마다 코드를 실행주니까 좋다. 수동으로 애플리케이션 열어서 확인할 필요가 없으니,

## React Testing Ribrary 철학

- 완고하다.
- rtl은 테스트를 위한 가상 돔을 생성하고, 상호작용을 위한 유틸리티를 제공한다.
- 때문에 브라우저 없이도 테스트 가능하게 해준다.

### 테스트의 유형

1. 유닛 테스트 - 보통 함수나 별개의 React 컴포넌트를 한 유닛 단위로 테스트한다.
2. 통합 테스트 - 여러 유닛의 유닛간의 상호작용을 테스트한다.
3. 기능 테스트 - 소프트 웨어의 특정 기능을 테스트한다. 특정 코드의 함수가 아닌 동작을 뜻한다.
- 일반적인 동작이란 폼을 입력하고, 출력하는등의 기능적인 의미를 뜻한다.
- 코드가 아닌 동작을 테스트 하는게 핵심이다. 사용자의 소프트웨어 사용을 테스트하는것을 권장한다. (사용자 관점에서의 테스트)
- RTL은 기능테스트를 권장한다.
1. 인수테스트 ,e2e 테스트 (endtoend) 서버나 브라우저 등이 필요하다. 

### 기능테스트  vs 유닛테스트

- 유닛 테스트는 테스트를 최대한 격리 시킨다. (고립)
- 함수나 컴포넌트를 테스트할때 의존성을 표현하는데, 의존성이 있다면 실제 버전대신 테스트버전을 실행한다. 그래서 문제 발생시 테스트에 실패하게 만드는 그 유닛이 문제다. 다른게 아니다.
- 격리상태의 컴포넌트를 테스트하면 상태의 차이점에 관해서만 테스트하게 되기 때문에 내부 테스트를 하게된다.
- 격리된 유닛에선 실패를 쉽고 정확하게 파악할 수 있다.
- 그러나 사용자가 소프트웨어를 바라보는 관점이랑은 관련이 적다.
- 그리고 리팩토링을 실패할 가능성이 있다.

### 기능테스트

- 유저테스트와 관련된 모든 테스트를 한다.
- 유저관점에서 상호작용에 대해 테스트하기 때문에 유저와 가깝다
- 테스트가 견고하다.
- 동작이 동일하게 유지되는 한 리팩토링해도 ㄱㅊ
- 실패한 테스트를 디버깅하기 어렵다. 어떤 코드가 테스트 실패의 원인인지 파악하기 어렵기때문이다.

RTL은 기능테스트가 단점보다 장점이 많다고 여기며 추천한다.

### 테스트 주도 개발 VS 행동 주도 개발

- BDD는 매우 복합적으로 규정되어있다.
- 여러개의 요소와, 프로세스, QA, 사람들이 필요한데 TDD는 그럴필요 없당

### 테스팅라이브러리와 접근성

- 스크린 리더와 같은 보조기술로 찾는것,
1. 누구나 액세스 가능한 쿼리 - 스크린 리더 등등
2. 시맨틱  쿼리
3. 테스트 IDs

스크린리더에 친화적으로 만들어야 좋다. getByRole같은걸로 찾을 수도 있고
